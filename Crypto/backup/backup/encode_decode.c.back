#include "./encode_decode.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// converts hex string to raw hex bytes
// int holds 32bits. each hex value is 4 bits
// so we can fit 8 hex values in one int.
int* hexRaw(char* str, uint len) {
    uint hlen = CEIL(len, 8);
    int* hex = malloc(sizeof(int)*hlen);
    *hex = 0; 
    int* head = hex;
    uint counter = 0;

    for(uint i = 0; i < len; i++) {
        *hex <<= 4;
        *hex |= HEX_CHECK(str[i]);
        counter++;

        if(counter == 8) {
            counter = 0;
            hex++;
            *hex = 0;
        }
    }

    return head;
}

// hex should be a struct
char* hexStr(int* hex, uint len) {
    char* str = malloc(sizeof(char)*len*8+1) ;
    str[len*8] = 0;
    int mask = 0xf;
    int tmp;
    int strIndex;

    for(int i = 0; i < len; i++) {
        tmp = hex[i];
        strIndex = (8 * (i+1))-1;
        for(int j = 8; j > 0; j--) {
            str[strIndex--] = HEX_STR(tmp & mask); 
            tmp >>= 4; 
        }
    }
    return str;
}
/*
// converts raw values to binary string representation
char* binaryStr(uint raw, uint* strlen) {

    // find max length of bits required to represent this number
    // i.e value x 8, needs 4 bits.
    // first value i that surpases x is the correct length
    // ex: i = 16 different values, len = 4. 
    // 2 ^ 4 = 16, max value 15 while 2^3 max value is 7.
    // edge case: if value equals max value it loops one more time.
    uint len = 1;
    for(uint i = 2; raw >= i; i *= 2) {
        len++;
        printf("here\n");
    }

    char* str = malloc(len + 1);
    str[len] = 0;

    uint k;
    for(int64_t i = len-1; i >= 0; i--) {
        k = raw >> i;

        if (k & 1) 
            str[len-1-i] = '1';
        else 
            str[len-1-i] = '0';
    }         
    
    if (strlen != NULL)
        *strlen = len;

    return str;
}

struct byte_64Base* base64(struct byte_32* b, uint len) { 

    struct byte_64Base* n = malloc(sizeof(struct byte_64Base)*len);
//    uint a = b.a & MASK_64B;
  //  uint left = b.a & 3;

    //n.a = a;
    //n.b = ((left << 6) | b.b) & MASK_64B;
    return n;
}


// converts given base to another base
struct radix* base(uint which, struct radix* r) {
    uint len;
    struct radix* n = malloc(sizeof(struct radix));
    switch(which) {
        case 2:
            {
            n->scheme = 2;
            n->raw = r->raw;
            n->str = binaryStr(r->raw, &len);
            n->len = len;
            return n; 
            }
        case 64:
   //         return base64(r, &len);
    return n;
        default:
            return NULL;
    }
}

// each byte struct holds 32 bits, 4 bytes
// find how many structs we need 
struct byte_32* populate_bytes(char* str, uint len) {
    uint byte_len = STR_BYTE_LEN(len);  

    if (byte_len < 4)  {
        byte_len = 1;
    }

    struct byte_32* bytes = malloc(sizeof(struct byte_32) * byte_len);

    int byte_index = 0;
    for(int i = 0; i < len; i += 4, byte_index++) {
        bytes[byte_index].a = HEX_CHECK(str[i]);

        if(i+1 < len) 
            bytes[byte_index].b = HEX_CHECK(str[i+1]);
        if(i+2 < len)
            bytes[byte_index].c = HEX_CHECK(str[i+2]);
        if(i+3 < len)
            bytes[byte_index].d = HEX_CHECK(str[i+3]);
    }

    return bytes;
}

void printBytes(struct byte_32* bytes,int len) {
    for(int i = 0; i < len; i++, bytes++) {
        printf("%i %i %i %i ", bytes->a, bytes->b, bytes->c, bytes->d);
    } 
    printf("\n");
}
*/
